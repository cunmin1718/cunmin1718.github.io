<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人笔记"><title>4. Kafka消费组(consumer group) | 记忆不靠谱</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">4. Kafka消费组(consumer group)</h1><a id="logo" href="/.">记忆不靠谱</a><p class="description">人生很奇妙，过好每一天</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">4. Kafka消费组(consumer group)</h1><div class="post-meta">Jul 13, 2019<span> | </span><span class="category"><a href="/categories/kafka/">kafka</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#消费者组-Consumer-Group"><span class="toc-number">1.</span> <span class="toc-text">消费者组 (Consumer Group)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是消费者组"><span class="toc-number">1.1.</span> <span class="toc-text">什么是消费者组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消费者位置-consumer-position"><span class="toc-number">1.2.</span> <span class="toc-text">消费者位置(consumer position)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位移管理-offset-management"><span class="toc-number">1.3.</span> <span class="toc-text">位移管理(offset management)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动VS手动"><span class="toc-number">1.3.1.</span> <span class="toc-text">自动VS手动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位移提交"><span class="toc-number">1.4.</span> <span class="toc-text">位移提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rebalance"><span class="toc-number">2.</span> <span class="toc-text">Rebalance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是rebalance？"><span class="toc-number">2.1.</span> <span class="toc-text">什么是rebalance？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候rebalance？"><span class="toc-number">2.2.</span> <span class="toc-text">什么时候rebalance？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何进行组内分区分配？"><span class="toc-number">2.3.</span> <span class="toc-text">如何进行组内分区分配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谁来执行rebalance和consumer-group管理？"><span class="toc-number">2.4.</span> <span class="toc-text">谁来执行rebalance和consumer group管理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何确定coordinator？"><span class="toc-number">2.5.</span> <span class="toc-text">如何确定coordinator？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rebalance-Generation"><span class="toc-number">2.6.</span> <span class="toc-text">Rebalance Generation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协议-protocol"><span class="toc-number">2.7.</span> <span class="toc-text">协议(protocol)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#liveness"><span class="toc-number">2.8.</span> <span class="toc-text">liveness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rebalance过程"><span class="toc-number">2.9.</span> <span class="toc-text">Rebalance过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer-group状态机"><span class="toc-number">2.10.</span> <span class="toc-text">consumer group状态机</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="消费者组-Consumer-Group"><a href="#消费者组-Consumer-Group" class="headerlink" title="消费者组 (Consumer Group)"></a>消费者组 (Consumer Group)</h2><h3 id="什么是消费者组"><a href="#什么是消费者组" class="headerlink" title="什么是消费者组"></a>什么是消费者组</h3><p>什么是consumer group? 一言以蔽之，consumer group是kafka提供的可扩展且具有容错性的消费者机制。既然是一个组，那么组内必然可以有多个消费者或消费者实例(consumer instance)，它们共享一个公共的ID，即group ID。组内的所有消费者协调在一起来消费订阅主题(subscribed topics)的所有分区(partition)。当然，每个分区只能由同一个消费组内的一个consumer来消费。（网上文章中说到此处各种炫目多彩的图就会紧跟着抛出来，我这里就不画了，请原谅）。个人认为，理解consumer group记住下面这三个特性就好了：</p>
<ul>
<li>consumer group下可以有一个或多个consumer instance，consumer instance可以是一个进程，也可以是一个线程</li>
<li>group.id是一个字符串，唯一标识一个consumer group</li>
<li>consumer group下订阅的topic下的每个分区只能分配给某个group下的一个consumer(当然该分区还可以被分配给其他group)</li>
</ul>
<h3 id="消费者位置-consumer-position"><a href="#消费者位置-consumer-position" class="headerlink" title="消费者位置(consumer position)"></a>消费者位置(consumer position)</h3><p>消费者在消费的过程中需要记录自己消费了多少数据，即消费位置信息。在Kafka中这个位置信息有个专门的术语：位移(offset)。很多消息引擎都把这部分信息保存在服务器端(broker端)。这样做的好处当然是实现简单，但会有三个主要的问题：</p>
<ol>
<li>broker从此变成有状态的，会影响伸缩性；</li>
<li>需要引入应答机制(acknowledgement)来确认消费成功。</li>
<li>由于要保存很多consumer的offset信息，必然引入复杂的数据结构，造成资源浪费。</li>
</ol>
<p>而Kafka选择了不同的方式：每个consumer group保存自己的位移信息，那么只需要简单的一个整数表示位置就够了；同时可以引入checkpoint机制定期持久化，简化了应答机制的实现。</p>
<h3 id="位移管理-offset-management"><a href="#位移管理-offset-management" class="headerlink" title="位移管理(offset management)"></a>位移管理(offset management)</h3><h4 id="自动VS手动"><a href="#自动VS手动" class="headerlink" title="自动VS手动"></a>自动VS手动</h4><p>Kafka默认是定期帮你自动提交位移的(enable.auto.commit = true)，你当然可以选择手动提交位移实现自己控制。另外kafka会定期把group消费情况保存起来，做成一个offset map，如下图所示：<br><img src="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.Kafka%E6%B6%88%E8%B4%B9%E7%BB%84/735367-20161226175429711-638862783.png" alt="image"></p>
<p>上图中表明了test-group这个组当前的消费情况。</p>
<h3 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h3><p>老版本的位移是提交到zookeeper中的，目录结构是：<code>/consumers/&lt;group.id&gt;/offsets/&lt;topic&gt;/&lt;partitionId&gt;</code>，但是zookeeper其实并不适合进行大批量的读写操作，尤其是写操作。因此kafka提供了另一种解决方案：增加<code>__consumeroffsets topic</code>，将offset信息写入这个topic，摆脱对zookeeper的依赖(指保存offset这件事情)。<code>__consumer_offsets</code>中的消息保存了每个consumer group某一时刻提交的offset信息。依然以上图中的consumer group为例，格式大概如下：<br><img src="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.Kafka%E6%B6%88%E8%B4%B9%E7%BB%84/735367-20161226175522507-1842910668.png" alt="image"></p>
<p><code>__consumers_offsets topic</code>配置了compact策略，使得它总是能够保存最新的位移信息，既控制了该topic总体的日志容量，也能实现保存最新offset的目的。<br>至于每个group保存到<code>__consumers_offsets</code>的哪个分区，如何查看的问题。请参见这篇文章:<a href="https://www.cnblogs.com/huxi2b/p/6061110.html" target="_blank" rel="noopener">Kafka 如何读取offset topic内容</a></p>
<h2 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h2><h3 id="什么是rebalance？"><a href="#什么是rebalance？" class="headerlink" title="什么是rebalance？"></a>什么是rebalance？</h3><p>rebalance本质上是一种协议，规定了一个consumer group下的所有consumer如何达成一致来分配订阅topic的每个分区。比如某个group下有20个consumer，它订阅了一个具有100个分区的topic。正常情况下，Kafka平均会为每个consumer分配5个分区。这个分配的过程就叫rebalance。</p>
<h3 id="什么时候rebalance？"><a href="#什么时候rebalance？" class="headerlink" title="什么时候rebalance？"></a>什么时候rebalance？</h3><p>这也是经常被提及的一个问题。rebalance的触发条件有三种：</p>
<ul>
<li>组成员发生变更(新consumer加入组、已有consumer主动离开组或已有consumer崩溃了——这两者的区别后面会谈到)</li>
<li>订阅主题数发生变更——这当然是可能的，如果你使用了正则表达式的方式进行订阅，那么新建匹配正则表达式的topic就会触发rebalance</li>
<li>订阅主题的分区数发生变更</li>
</ul>
<h3 id="如何进行组内分区分配？"><a href="#如何进行组内分区分配？" class="headerlink" title="如何进行组内分区分配？"></a>如何进行组内分区分配？</h3><p>之前提到了group下的所有consumer都会协调在一起共同参与分配，这是如何完成的？Kafka新版本consumer默认提供了两种分配策略：range和round-robin。当然Kafka采用了可插拔式的分配策略，你可以创建自己的分配器以实现不同的分配策略。实际上，由于目前range和round-robin两种分配器都有一些弊端，Kafka社区已经提出第三种分配器来实现更加公平的分配策略，只是目前还在开发中。我们这里只需要知道consumer group默认已经帮我们把订阅topic的分区分配工作做好了就行了。<br>简单举个例子，假设目前某个consumer group下有两个consumer： A和B，当第三个成员加入时，kafka会触发rebalance并根据默认的分配策略重新为A、B和C分配分区，如下图所示：<br><img src="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.Kafka%E6%B6%88%E8%B4%B9%E7%BB%84/735367-20161226175710289-1164779517.png" alt="image"></p>
<h3 id="谁来执行rebalance和consumer-group管理？"><a href="#谁来执行rebalance和consumer-group管理？" class="headerlink" title="谁来执行rebalance和consumer group管理？"></a>谁来执行rebalance和consumer group管理？</h3><p>Kafka提供了一个角色：coordinator来执行对于consumer group的管理。坦率说kafka对于coordinator的设计与修改是一个很长的故事。最新版本的coordinator也与最初的设计有了很大的不同。这里我只想提及两次比较大的改变。</p>
<p>首先是0.8版本的coordinator，那时候的coordinator是依赖zookeeper来实现对于consumer group的管理的。Coordinator监听zookeeper的<code>/consumers/&lt;group&gt;/ids</code>的子节点变化以及<code>/brokers/topics/&lt;topic&gt;</code>数据变化来判断是否需要进行rebalance。group下的每个consumer都自己决定要消费哪些分区，并把自己的决定抢先在zookeeper中的<code>/consumers/&lt;group&gt;/owners/&lt;topic&gt;/&lt;partition&gt;</code>下注册。很明显，这种方案要依赖于zookeeper的帮助，而且每个consumer是单独做决定的，没有那种“大家属于一个组，要协商做事情”的精神。</p>
<p>基于这些潜在的弊端，0.9版本的kafka改进了coordinator的设计，提出了group coordinator——每个consumer group都会被分配一个这样的coordinator用于组管理和位移管理。这个group coordinator比原来承担了更多的责任，比如组成员管理、位移提交保护机制等。当新版本consumer group的第一个consumer启动的时候，它会去和kafka server确定谁是它们组的coordinator。之后该group内的所有成员都会和该coordinator进行协调通信。显而易见，这种coordinator设计不再需要zookeeper了，性能上可以得到很大的提升。后面的所有部分我们都将讨论最新版本的coordinator设计。</p>
<h3 id="如何确定coordinator？"><a href="#如何确定coordinator？" class="headerlink" title="如何确定coordinator？"></a>如何确定coordinator？</h3><p>上面简单讨论了新版coordinator的设计，那么consumer group如何确定自己的coordinator是谁呢？ 简单来说分为两步：</p>
<ul>
<li><p>确定consumer group位移信息写入<code>__consumers_offsets</code>的哪个分区。具体计算公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__consumers_offsets partition# = Math.abs(groupId.hashCode() % groupMetadataTopicPartitionCount)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：groupMetadataTopicPartitionCount由offsets.topic.num.partitions指定，默认是50个分区。</p>
</blockquote>
</li>
<li><p>该分区leader所在的broker就是被选定的coordinator</p>
</li>
</ul>
<h3 id="Rebalance-Generation"><a href="#Rebalance-Generation" class="headerlink" title="Rebalance Generation"></a>Rebalance Generation</h3><p>JVM GC的分代收集就是这个词(严格来说是generational)，我这里把它翻译成“届”好了，它表示了rebalance之后的一届成员，主要是用于保护consumer group，隔离无效offset提交的。比如上一届的consumer成员是无法提交位移到新一届的consumer group中。我们有时候可以看到ILLEGAL_GENERATION的错误，就是kafka在抱怨这件事情。每次group进行rebalance之后，generation号都会加1，表示group进入到了一个新的版本，如下图所示： Generation 1时group有3个成员，随后成员2退出组，coordinator触发rebalance，consumer group进入Generation 2，之后成员4加入，再次触发rebalance，group进入Generation 3.<br><img src="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.Kafka%E6%B6%88%E8%B4%B9%E7%BB%84/735367-20161226175822570-898409869.png" alt="image"></p>
<h3 id="协议-protocol"><a href="#协议-protocol" class="headerlink" title="协议(protocol)"></a>协议(protocol)</h3><p>前面说过了， rebalance本质上是一组协议。group与coordinator共同使用它来完成group的rebalance。目前kafka提供了5个协议来处理与consumer group coordination相关的问题：</p>
<ul>
<li>Heartbeat请求：consumer需要定期给coordinator发送心跳来表明自己还活着</li>
<li>LeaveGroup请求：主动告诉coordinator我要离开consumer group</li>
<li>SyncGroup请求：group leader把分配方案告诉组内所有成员</li>
<li>JoinGroup请求：成员请求加入组</li>
<li>DescribeGroup请求：显示组的所有信息，包括成员信息，协议名称，分配方案，订阅信息等。通常该请求是给管理员使用</li>
</ul>
<p>Coordinator在rebalance的时候主要用到了前面4种请求。</p>
<h3 id="liveness"><a href="#liveness" class="headerlink" title="liveness"></a>liveness</h3><p>consumer如何向coordinator证明自己还活着？ 通过定时向coordinator发送Heartbeat请求。如果超过了设定的超时时间，那么coordinator就认为这个consumer已经挂了。一旦coordinator认为某个consumer挂了，那么它就会开启新一轮rebalance，并且在当前其他consumer的心跳response中添加“REBALANCE_IN_PROGRESS”，告诉其他consumer：不好意思各位，你们重新申请加入组吧！</p>
<h3 id="Rebalance过程"><a href="#Rebalance过程" class="headerlink" title="Rebalance过程"></a>Rebalance过程</h3><p>终于说到consumer group执行rebalance的具体流程了。很多用户估计对consumer内部的工作机制也很感兴趣。下面就跟大家一起讨论一下。当然我必须要明确表示，rebalance的前提是coordinator已经确定了。</p>
<p>总体而言，rebalance分为2步：Join和Sync</p>
<ol>
<li>Join， 顾名思义就是加入组。这一步中，所有成员都向coordinator发送JoinGroup请求，请求入组。一旦所有成员都发送了JoinGroup请求，coordinator会从中选择一个consumer担任leader的角色，并把组成员信息以及订阅信息发给leader——注意leader和coordinator不是一个概念。leader负责消费分配方案的制定。</li>
<li>Sync，这一步leader开始分配消费方案，即哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案封装进SyncGroup请求中发给coordinator，非leader也会发SyncGroup请求，只是内容为空。coordinator接收到分配方案之后会把方案塞进SyncGroup的response中发给各个consumer。这样组内的所有成员就都知道自己应该消费哪些分区了。</li>
</ol>
<p>还是拿几张图来说明吧，首先是加入组的过程:<br><img src="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.Kafka%E6%B6%88%E8%B4%B9%E7%BB%84/735367-20161226175922086-1237318351.png" alt="image"></p>
<p>值得注意的是， 在coordinator收集到所有成员请求前，它会把已收到请求放入一个叫purgatory(炼狱)的地方。记得国内有篇文章以此来证明kafka开发人员都是很有文艺范的，写得也是比较有趣，有兴趣可以去搜搜。<br>然后是分发分配方案的过程，即SyncGroup请求：<br><img src="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.Kafka%E6%B6%88%E8%B4%B9%E7%BB%84/735367-20161226180005242-1302422077.png" alt="image"></p>
<blockquote>
<p>注意！！ consumer group的分区分配方案是在客户端执行的！Kafka将这个权利下放给客户端主要是因为这样做可以有更好的灵活性。比如这种机制下我可以实现类似于Hadoop那样的机架感知(rack-aware)分配方案，即为consumer挑选同一个机架下的分区数据，减少网络传输的开销。Kafka默认为你提供了两种分配策略：range和round-robin。由于这不是本文的重点，这里就不再详细展开了，你只需要记住你可以覆盖consumer的参数：partition.assignment.strategy来实现自己分配策略就好了。</p>
</blockquote>
<h3 id="consumer-group状态机"><a href="#consumer-group状态机" class="headerlink" title="consumer group状态机"></a>consumer group状态机</h3><p>和很多kafka组件一样，group也做了个状态机来表明组状态的流转。coordinator根据这个状态机会对consumer group做不同的处理，如下图所示:<br><img src="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.Kafka%E6%B6%88%E8%B4%B9%E7%BB%84/735367-20161226180046945-1657832046.png" alt="image"></p>
<p>简单说明下图中的各个状态：</p>
<ul>
<li>Dead：组内已经没有任何成员的最终状态，组的元数据也已经被coordinator移除了。这种状态响应各种请求都是一个response： UNKNOWN_MEMBER_ID</li>
<li>Empty：组内无成员，但是位移信息还没有过期。这种状态只能响应JoinGroup请求</li>
<li>PreparingRebalance：组准备开启新的rebalance，等待成员加入</li>
<li>AwaitingSync：正在等待leader consumer将分配方案传给各个成员</li>
<li>Stable：rebalance完成！可以开始消费了~</li>
</ul>
</div><div class="tags"><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></div><div class="post-nav"><a class="pre" href="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/5.Kafka%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96offset%20topic%E5%86%85%E5%AE%B9/">5.Kafka 如何读取offset topic内容</a><a class="next" href="/2019/07/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/3.%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/">3. 高可靠性使用分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://cunmin1718.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Beat/">Beat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES/">ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Elasticsearch/">Elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kibana/">Kibana</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Logstash/">Logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NIFI/">NIFI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nexus/">Nexus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ansible/">ansible</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/drill/">drill</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ganglia/">ganglia</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gitLab/">gitLab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/greenplum/">greenplum</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/greenplum/PostgreSQL/">PostgreSQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/impala/">impala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/oracle/">oracle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scrapy/">scrapy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/seaweed/">seaweed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/">数据仓库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/" style="font-size: 15px;">数据仓库</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">容器</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" style="font-size: 15px;">项目开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">运维</a> <a href="/tags/ELK/" style="font-size: 15px;">ELK</a> <a href="/tags/hadoop%E4%BD%93%E7%B3%BB/" style="font-size: 15px;">hadoop体系</a> <a href="/tags/%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/" style="font-size: 15px;">分析引擎</a> <a href="/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/" style="font-size: 15px;">文件存储</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/" style="font-size: 15px;">日志收集</a> <a href="/tags/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7/" style="font-size: 15px;">运维监控</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/nifi/NiFi%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/">NiFi用户指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/20/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/nifi/nifi%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/">nifi组件介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/greenplum/%E5%88%86%E5%8C%BA%E8%A1%A8/">分区表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/postgreSQL/PrepareStatement%E7%9A%84%E5%8A%9F%E4%B8%8E%E8%BF%87/">PrepareStatement的功与过</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/greenplum/%E8%B5%84%E6%BA%90%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86/">资源队列管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/30/python/python/Python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%96%B9%E6%B3%95/">Python常用内建方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/29/python/python/args%E5%92%8Ckwargs%E7%9A%84%E5%8C%BA%E5%88%AB/">args和kwargs的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E9%85%8D%E7%BD%AE/">redis配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%AE%89%E8%A3%85/">redis安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/12/python/scrapy/Middleware/HTTP%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%B7%A5%E4%BD%9C/">4. HTTP缓存与离线工作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">记忆不靠谱.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>