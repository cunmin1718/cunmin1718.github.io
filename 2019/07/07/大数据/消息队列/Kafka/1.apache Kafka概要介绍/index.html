<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人笔记"><title>1. apache Kafka概要介绍 | 记忆不靠谱</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">1. apache Kafka概要介绍</h1><a id="logo" href="/.">记忆不靠谱</a><p class="description">人生很奇妙，过好每一天</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">1. apache Kafka概要介绍</h1><div class="post-meta">Jul 7, 2019<span> | </span><span class="category"><a href="/categories/kafka/">kafka</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景介绍"><span class="toc-number">1.</span> <span class="toc-text">背景介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka名词解释和工作方式"><span class="toc-number">1.1.</span> <span class="toc-text">kafka名词解释和工作方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka特性："><span class="toc-number">2.</span> <span class="toc-text">kafka特性：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可靠性（一致性"><span class="toc-number">3.</span> <span class="toc-text">可靠性（一致性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafak系统扩展性"><span class="toc-number">4.</span> <span class="toc-text">kafak系统扩展性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka设计目标"><span class="toc-number">5.</span> <span class="toc-text">kafka设计目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Producer负载均衡和HA机制"><span class="toc-number">6.</span> <span class="toc-text">Producer负载均衡和HA机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consumer的pull机制"><span class="toc-number">7.</span> <span class="toc-text">Consumer的pull机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consumer与topic关系以及机制"><span class="toc-number">8.</span> <span class="toc-text">Consumer与topic关系以及机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Producer均衡算法"><span class="toc-number">9.</span> <span class="toc-text">Producer均衡算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consumer均衡算法"><span class="toc-number">10.</span> <span class="toc-text">Consumer均衡算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka-broker集群内broker之间replica机制"><span class="toc-number">11.</span> <span class="toc-text">kafka broker集群内broker之间replica机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka判定一个follower存活与否的条件有2个"><span class="toc-number">11.1.</span> <span class="toc-text">kafka判定一个follower存活与否的条件有2个:</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>kafka是最初由Linkedin公司开发，使用Scala语言编写，Kafka是一个分布式、分区的、多副本的、多订阅者的日志系统(分布式MQ系统)，可以用于web/nginx日志，搜索日志，监控日志，访问日志等等。<br>kafka目前支持多种客户端语言：java，python，c++，php等等</p>
<h3 id="kafka名词解释和工作方式"><a href="#kafka名词解释和工作方式" class="headerlink" title="kafka名词解释和工作方式"></a>kafka名词解释和工作方式</h3><ul>
<li>Producer ：消息生产者，就是向kafka broker发消息的客户端。</li>
<li>Consumer ：消息消费者，向kafka broker取消息的客户端</li>
<li>Topic ：咋们可以理解为一个队列。</li>
<li>Consumer Group （CG）：这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</li>
<li>Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。</li>
<li>Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。</li>
<li>Offset：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka</li>
</ul>
<h2 id="kafka特性："><a href="#kafka特性：" class="headerlink" title="kafka特性："></a>kafka特性：</h2><ul>
<li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li>
<li>高吞吐量：即使是非常普通的硬件kafka也可以支持每秒数十万的消息。</li>
<li>支持同步和异步复制两种HA</li>
<li>Consumer客户端pull，随机读,利用sendfile系统调用，zero-copy ,批量拉数据</li>
<li>消费状态保存在客户端</li>
<li>消息存储顺序写</li>
<li>数据迁移、扩容对用户透明</li>
<li>支持Hadoop并行数据加载。</li>
<li>支持online和offline的场景。</li>
<li>持久化：通过将数据持久化到硬盘以及replication防止数据丢失。</li>
<li>scale out：无需停机即可扩展机器。</li>
<li>定期删除机制，支持设定partitions的segment file保留时间。</li>
</ul>
<h2 id="可靠性（一致性"><a href="#可靠性（一致性" class="headerlink" title="可靠性（一致性)"></a>可靠性（一致性)</h2><p>kafka(MQ)要实现从producer到consumer之间的可靠的消息传送和分发。传统的MQ系统通常都是通过broker和consumer间的确认（ack）机制实现的，并在broker保存消息分发的状态。<br>即使这样一致性也是很难保证的。kafka的做法是由consumer自己保存状态，也不要任何确认。这样虽然consumer负担更重，但其实更灵活了。<br>因为不管consumer上任何原因导致需要重新处理消息，都可以再次从broker获得。</p>
<h2 id="kafak系统扩展性"><a href="#kafak系统扩展性" class="headerlink" title="kafak系统扩展性"></a>kafak系统扩展性</h2><p>kafka使用zookeeper来实现动态的集群扩展，不需要更改客户端（producer和consumer）的配置。broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新。<br>而客户端会在zookeeper上注册相关的watcher。一旦zookeeper发生变化，客户端能及时感知并作出相应调整。这样就保证了添加或去除broker时，各broker间仍能自动实现负载均衡。</p>
<h2 id="kafka设计目标"><a href="#kafka设计目标" class="headerlink" title="kafka设计目标"></a>kafka设计目标</h2><p>高吞吐量是其核心设计之一。</p>
<ul>
<li>数据磁盘持久化：消息不在内存中cache，直接写入到磁盘，充分利用磁盘的顺序读写性能。</li>
<li>zero-copy：减少IO操作步骤。</li>
<li>支持数据批量发送和拉取。</li>
<li>支持数据压缩。</li>
<li>Topic划分为多个partition，提高并行处理能力。</li>
</ul>
<h2 id="Producer负载均衡和HA机制"><a href="#Producer负载均衡和HA机制" class="headerlink" title="Producer负载均衡和HA机制"></a>Producer负载均衡和HA机制</h2><ul>
<li>producer根据用户指定的算法，将消息发送到指定的partition。</li>
<li>存在多个partiiton，每个partition有自己的replica，每个replica分布在不同的Broker节点上。</li>
<li>多个partition需要选取出lead partition，lead partition负责读写，并由zookeeper负责fail over。</li>
<li>通过zookeeper管理broker与consumer的动态加入与离开。</li>
</ul>
<h2 id="Consumer的pull机制"><a href="#Consumer的pull机制" class="headerlink" title="Consumer的pull机制"></a>Consumer的pull机制</h2><p>由于kafka broker会持久化数据，broker没有cahce压力，因此，consumer比较适合采取pull的方式消费数据，具体特别如下：</p>
<ul>
<li>简化kafka设计，降低了难度。</li>
<li>Consumer根据消费能力自主控制消息拉取速度。</li>
<li>consumer根据自身情况自主选择消费模式，例如批量，重复消费，从制定partition或位置(offset)开始消费等.</li>
</ul>
<h2 id="Consumer与topic关系以及机制"><a href="#Consumer与topic关系以及机制" class="headerlink" title="Consumer与topic关系以及机制"></a>Consumer与topic关系以及机制</h2><p>本质上kafka只支持Topic.每个consumer属于一个consumer group;反过来说,每个group中可以有多个consumer.对于Topic中的一条特定的消息,只会被订阅此Topic的每个group中的一个consumer消费,此消息不会发送给一个group的多个consumer;那么一个group中所有的consumer将会交错的消费整个Topic.</p>
<p>如果所有的consumer都具有相同的group,这种情况和JMS queue模式很像;消息将会在consumers之间负载均衡.</p>
<p>如果所有的consumer都具有不同的group,那这就是”发布-订阅”;消息将会广播给所有的消费者.</p>
<p>在kafka中,一个partition中的消息只会被group中的一个consumer消费(同一时刻);每个group中consumer消息消费互相独立;我们可以认为一个group是一个”订阅”者,一个Topic中的每个partions,只会被一个”订阅者”中的一个consumer消费,不过一个consumer可以同时消费多个partitions中的消息.</p>
<p>kafka只能保证一个partition中的消息被某个consumer消费时是顺序的.事实上,从Topic角度来说,当有多个partitions时,消息仍不是全局有序的. </p>
<p>通常情况下,一个group中会包含多个consumer,这样不仅可以提高topic中消息的并发消费能力,而且还能提高”故障容错”性,如果group中的某个consumer失效,那么其消费的partitions将会有其他consumer自动接管.kafka的设计原理决定,对于一个topic,同一个group中不能有多于partitions个数的consumer同时消费,否则将意味着某些consumer将无法得到消息.</p>
<h2 id="Producer均衡算法"><a href="#Producer均衡算法" class="headerlink" title="Producer均衡算法"></a>Producer均衡算法</h2><p>kafka集群中的任何一个broker,都可以向producer提供metadata信息,这些metadata中包含”集群中存活的servers列表”/“partitions leader列表”等信息(请参看zookeeper中的节点信息).当producer获取到metadata信心之后, producer将会和Topic下所有partition leader保持socket连接;</p>
<p>消息由producer直接通过socket发送到broker,中间不会经过任何”路由层”.事实上,消息被路由到哪个partition上,有producer客户端决定.比如可以采用”random””key-hash””轮询”等,如果一个topic中有多个partitions,那么在producer端实现”消息均衡分发”是必要的.在producer端的配置文件中,开发者可以指定partition路由的方式.</p>
<h2 id="Consumer均衡算法"><a href="#Consumer均衡算法" class="headerlink" title="Consumer均衡算法"></a>Consumer均衡算法</h2><p>当一个group中,有consumer加入或者离开时,会触发partitions均衡.均衡的最终目的,是提升topic的并发消费能力.</p>
<p>1) 假如topic1,具有如下partitions: P0,P1,P2,P3<br>2) 加入group中,有如下consumer: C0,C1<br>3) 首先根据partition索引号对partitions排序: P0,P1,P2,P3<br>4) 根据consumer.id排序: C0,C1<br>5) 计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)<br>6) 然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i * M),P((i + 1) * M -1)]</p>
<h2 id="kafka-broker集群内broker之间replica机制"><a href="#kafka-broker集群内broker之间replica机制" class="headerlink" title="kafka broker集群内broker之间replica机制"></a>kafka broker集群内broker之间replica机制</h2><p>kafka中,replication策略是基于partition,而不是topic;kafka将每个partition数据复制到多个server上,任何一个partition有一个leader和多个follower(可以没有);</p>
<p>备份的个数可以通过broker配置文件来设定.leader处理所有的read-write请求,follower需要和leader保持同步.Follower就像一个”consumer”,消费消息并保存在本地日志中;leader负责跟踪所有的follower状态,如果follower”落后”太多或者失效,leader将会把它从replicas同步列表中删除.</p>
<p>当所有的follower都将一条消息保存成功,此消息才被认为是”committed”,那么此时consumer才能消费它,这种同步策略,就要求follower和leader之间必须具有良好的网络环境.</p>
<p>即使只有一个replicas实例存活,仍然可以保证消息的正常发送和接收,只要zookeeper集群存活即可.(备注:不同于其他分布式存储,比如hbase需要”多数派”存活才行)</p>
<h3 id="kafka判定一个follower存活与否的条件有2个"><a href="#kafka判定一个follower存活与否的条件有2个" class="headerlink" title="kafka判定一个follower存活与否的条件有2个:"></a>kafka判定一个follower存活与否的条件有2个:</h3><p>1) follower需要和zookeeper保持良好的链接<br>2) 它必须能够及时的跟进leader,不能落后太多.<br>如果同时满足上述2个条件,那么leader就认为此follower是”活跃的”.如果一个follower失效(server失效)或者落后太多,leader将会把它从同步列表中移除[备注:如果此replicas落后太多,它将会继续从leader中fetch数据,直到足够up-to-date,然后再次加入到同步列表中;kafka不会更换replicas宿主!因为”同步列表”中replicas需要足够快,这样才能保证producer发布消息时接受到ACK的延迟较小。</p>
<p>当leader失效时,需在followers中选取出新的leader,可能此时follower落后于leader,因此需要选择一个”up-to-date”的follower.kafka中leader选举并没有采用”投票多数派”的算法,因为这种算法对于”网络稳定性”/“投票参与者数量”等条件有较高的要求,而且kafka集群的设计,还需要容忍N-1个replicas失效.对于kafka而言,每个partition中所有的replicas信息都可以在zookeeper中获得,那么选举leader将是一件非常简单的事情.选择follower时需要兼顾一个问题,就是新leader server上所已经承载的partition leader的个数,如果一个server上有过多的partition leader,意味着此server将承受着更多的IO压力.</p>
<p>在选举新leader,需要考虑到”负载均衡”,partition leader较少的broker将会更有可能成为新的leader.</p>
<p>在整几个集群中,只要有一个replicas存活,那么此partition都可以继续接受读写操作.</p>
</div><div class="tags"><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></div><div class="post-nav"><a class="pre" href="/2019/07/07/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/Maven/Maven%E7%9A%84pom%E6%A0%87%E7%AD%BE/">Maven的pom标签</a><a class="next" href="/2019/07/07/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/Maven/13.%20%E6%8F%92%E4%BB%B6versions-maven-plugin/">插件versions-maven-plugin</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://cunmin1718.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Beat/">Beat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES/">ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Elasticsearch/">Elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kibana/">Kibana</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Logstash/">Logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NIFI/">NIFI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nexus/">Nexus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ansible/">ansible</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/drill/">drill</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ganglia/">ganglia</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gitLab/">gitLab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/greenplum/">greenplum</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/greenplum/PostgreSQL/">PostgreSQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/impala/">impala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/oracle/">oracle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scrapy/">scrapy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/seaweed/">seaweed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/">数据仓库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/" style="font-size: 15px;">数据仓库</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">容器</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" style="font-size: 15px;">项目开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">运维</a> <a href="/tags/ELK/" style="font-size: 15px;">ELK</a> <a href="/tags/hadoop%E4%BD%93%E7%B3%BB/" style="font-size: 15px;">hadoop体系</a> <a href="/tags/%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/" style="font-size: 15px;">分析引擎</a> <a href="/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/" style="font-size: 15px;">文件存储</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/" style="font-size: 15px;">日志收集</a> <a href="/tags/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7/" style="font-size: 15px;">运维监控</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/nifi/NiFi%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/">NiFi用户指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/20/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/nifi/nifi%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/">nifi组件介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/greenplum/%E5%88%86%E5%8C%BA%E8%A1%A8/">分区表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/07/%E6%95%B0%E6%8D%AE%E5%BA%93/postgreSQL/PrepareStatement%E7%9A%84%E5%8A%9F%E4%B8%8E%E8%BF%87/">PrepareStatement的功与过</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/greenplum/%E8%B5%84%E6%BA%90%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86/">资源队列管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/30/python/python/Python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%96%B9%E6%B3%95/">Python常用内建方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/29/python/python/args%E5%92%8Ckwargs%E7%9A%84%E5%8C%BA%E5%88%AB/">args和kwargs的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E9%85%8D%E7%BD%AE/">redis配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%AE%89%E8%A3%85/">redis安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/12/python/scrapy/Middleware/HTTP%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%B7%A5%E4%BD%9C/">4. HTTP缓存与离线工作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">记忆不靠谱.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>