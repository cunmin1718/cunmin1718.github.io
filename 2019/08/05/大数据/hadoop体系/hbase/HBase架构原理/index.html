<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人笔记"><title>1. HBase架构原理 | 记忆不靠谱</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">1. HBase架构原理</h1><a id="logo" href="/.">记忆不靠谱</a><p class="description">人生很奇妙，过好每一天</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">1. HBase架构原理</h1><div class="post-meta">Aug 5, 2019<span> | </span><span class="category"><a href="/categories/hbase/">hbase</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HBase简介"><span class="toc-number">1.</span> <span class="toc-text">HBase简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hbase是什么"><span class="toc-number">1.1.</span> <span class="toc-text">Hbase是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HBase的特点"><span class="toc-number">1.2.</span> <span class="toc-text">HBase的特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HBase数据模型"><span class="toc-number">2.</span> <span class="toc-text">HBase数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HBase的逻辑数据模型"><span class="toc-number">2.1.</span> <span class="toc-text">HBase的逻辑数据模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HBase的物理数据模型"><span class="toc-number">2.2.</span> <span class="toc-text">HBase的物理数据模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HBase物理存储"><span class="toc-number">2.3.</span> <span class="toc-text">HBase物理存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HBase系统架构"><span class="toc-number">3.</span> <span class="toc-text">HBase系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HBase架构图"><span class="toc-number">3.1.</span> <span class="toc-text">HBase架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HRegion定位"><span class="toc-number">3.2.</span> <span class="toc-text">HRegion定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HBase工作流程"><span class="toc-number">4.</span> <span class="toc-text">HBase工作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HBase的高可用"><span class="toc-number">5.</span> <span class="toc-text">HBase的高可用</span></a></li></ol></div></div><div class="post-content"><h1 id="HBase简介"><a href="#HBase简介" class="headerlink" title="HBase简介"></a>HBase简介</h1><h2 id="Hbase是什么"><a href="#Hbase是什么" class="headerlink" title="Hbase是什么"></a>Hbase是什么</h2><p>HBase是一种构建在HDFS之上的分布式、面向列、多版本、非关系型的数据库。在需要实时读写、随机访问超大规模数据集时，可以使用HBase。HBase 是Google Bigtable 的开源实现。</p>
<h2 id="HBase的特点"><a href="#HBase的特点" class="headerlink" title="HBase的特点"></a>HBase的特点</h2><p>大：一个表可以有上亿行，上百万列。<br>面向列：面向列（组）的存储和权限控制，列（组）独立检索。<br>稀疏：对于为空（NULL）的列，并不占用存储空间，因此，表可以设计的非常稀疏。<br>无模式：每一行都有一个可以排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列。<br>数据多版本：每个单元中的数据可以有多个版本，默认情况下，版本号自动分配，版本号就是单元格插入时的时间戳。<br>数据类型单一：HBase中的数据都是字符串，没有类型，存储在hbase上的都是字节数组。</p>
<a id="more"></a>

<h1 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h1><p>HBase 以表的形式存储数据。表由行和列组成。列划分为若干个列族（row family），如下图所示。<br><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-57f26aa05cdbc5db.png" alt="img"></p>
<h2 id="HBase的逻辑数据模型"><a href="#HBase的逻辑数据模型" class="headerlink" title="HBase的逻辑数据模型"></a>HBase的逻辑数据模型</h2><p><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-46788b1d0ed7b43c.png" alt="img"></p>
<h2 id="HBase的物理数据模型"><a href="#HBase的物理数据模型" class="headerlink" title="HBase的物理数据模型"></a>HBase的物理数据模型</h2><p><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-6b24f86558b39384.png" alt="img"></p>
<p>逻辑数据模型中空白cell在物理上是不存储的，因此若一个请求为要获取t8时间的contents:html，他的结果就是空。相似的，若请求为获取t9时间的anchor:my.look.ca，结果也是空。但是，如果不指明时间，将会返回最新时间的行，每个最新的都会返回</p>
<ul>
<li><p>Row Key<br>与 NoSQL 数据库一样，Row Key 是用来检索记录的主键。几种访问 HBase table 中的行方式：<br>1) 通过单个 Row Key 访问。<br>2) 通过 Row Key 的 range 全表扫描。<br>3) Row Key 可以使任意字符串（最大长度是64KB，实际应用中长度一般为 10 ~ 100bytes），在HBase 内部，Row Key 保存为字节数组。</p>
</li>
<li><p>列族<br>HBase 表中的每个列都归属于某个列族。列族是表的 Schema 的一部分（而列不是），必须在使用表之前定义。列名都以列族作为前缀，例如 courses:history、courses:math 都属于 courses 这个列族。<br>访问控制、磁盘和内存的使用统计都是在列族层面进行的。在实际应用中，列族上的控制权限能帮助我们管理不同类型的应用， 例如，允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、 一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）。</p>
</li>
<li><p>Cell<br>时间戳HBase 中通过 Row 和 Columns 确定的一个存储单元称为 Cell。每个 Cell 都保存着同一份数据的多个版本。 版本通过时间戳来索引，时间戳的类型是 64 位整型。时间戳可以由HBase（在数据写入时自动）赋值， 此时时间戳是精确到毫秒的当前系统时间。时间戳也 可以由客户显示赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个 Cell 中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。<br>为了避免数据存在过多版本造成的管理（包括存储和索引）负担，HBase 提供了两种数据版本回收方式。 一是保存数据的最后 n 个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
</li>
</ul>
<h2 id="HBase物理存储"><a href="#HBase物理存储" class="headerlink" title="HBase物理存储"></a>HBase物理存储</h2><p>Table在行的方向上分割为多个HRegion，每个HRegion分散在不同的RegionServer中。<br><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-f4ccee84c280022c.png" alt="img"></p>
<p>每个HRegion由多个Store构成，每个Store由一个MemStore和0或多个StoreFile组成，每个Store保存一个Columns Family<br><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-e2429d9d5330a076.png" alt="img"></p>
<h1 id="HBase系统架构"><a href="#HBase系统架构" class="headerlink" title="HBase系统架构"></a>HBase系统架构</h1><h2 id="HBase架构图"><a href="#HBase架构图" class="headerlink" title="HBase架构图"></a>HBase架构图</h2><p><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-94b81418ee54943d.jpg" alt="img"></p>
<p>从HBase的架构图上可以看出，HBase中的组件包括Client、Zookeeper、HMaster、HRegionServer、HRegion、Store、MemStore、StoreFile、HFile、HLog等，接下来介绍他们的作用。<br>HBase中的每张表都通过行键按照一定的范围被分割成多个子表（HRegion），默认一个HRegion超过256M就要被分割成两个，这个过程由HRegionServer管理，而HRegion的分配由HMaster管理。</p>
<ul>
<li><p>Client<br>包含访问HBase的接口，并维护cache来加快对HBase的访问。</p>
</li>
<li><p>Zookeeper<br>HBase依赖Zookeeper，默认情况下HBase管理Zookeeper实例(启动或关闭Zookeeper),Master与RegionServers启动时会向Zookeeper注册。<br>保证任何时候，集群中只有一个master<br>实时监控Region server的上线和下线信息。并实时通知给master<br>存储HBase的schema和table元数据</p>
</li>
<li><p>HMaster<br>为Region server分配region<br>负责Region server的负载均衡<br>发现失效的Region server并重新分配其上的region。<br>处理schema更新请求。</p>
</li>
<li><p>HRegionServer<br>维护master分配给他的region，处理对这些region的io请求。<br>负责切分正在运行过程中变的过大的region。<br>注意：client访问hbase上的数据时不需要master的参与，因为数据寻址访问zookeeper和region server，而数据读写访问region server。master仅仅维护table和region的元数据信息，而table的元数据信息保存在zookeeper上，因此master负载很低。</p>
</li>
<li><p>HRegion<br>table在行的方向上分隔为多个Region。Region是HBase中分布式存储和负载均衡的最小单元，即不同的region可以分别在不同的Region Server上，但同一个Region是不会拆分到多个server上。<br>Region按大小分隔，每个表一般是只有一个region。随着数据不断插入表，region不断增大，当region的某个列族达到一个阈值时就会分成两个新的region。<br>每个region由以下信息标识：&lt; 表名,startRowkey,创建时间&gt;<br>由目录表(-ROOT-和.META.)记录该region的endRowkey</p>
</li>
<li><p>Store<br>每一个region由一个或多个store组成，至少是一个store，hbase会把一起访问的数据放在一个store里面，即为每个 ColumnFamily建一个store，如果有几个ColumnFamily，也就有几个Store。一个Store由一个memStore和0或者 多个StoreFile组成。 HBase以store的大小来判断是否需要切分region</p>
</li>
<li><p>MemStore<br>memStore 是放在内存里的。保存修改的数据即keyValues。当memStore的大小达到一个阀值（默认128MB）时，memStore会被flush到文 件，即生成一个快照。目前hbase 会有一个线程来负责memStore的flush操作。</p>
</li>
<li><p>StoreFile<br>memStore内存中的数据写到文件后就是StoreFile，StoreFile底层是以HFile的格式保存。</p>
</li>
<li><p>HFile<br>HBase中KeyValue数据的存储格式，HFile是Hadoop的 二进制格式文件，实际上StoreFile就是对Hfile做了轻量级包装，即StoreFile底层就是HFile<br>HFile的存储格式如下：<br><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-a333a478b064f506.png" alt="img"><br>HFile由多个Data Block、Meta Block、FileInfo、Data Index、Meta Index、Trailer组成，其中Data Block是HBase的最小存储单元，在前文中提到的BlockCache就是基于Data Block的缓存的。一个Data Block由一个魔数和一系列的KeyValue(Cell)组成，魔数是一个随机的数字，用于表示这是一个Data Block类型，以快速监测这个Data Block的格式，防止数据的破坏。Data Block的大小可以在创建Column Family时设置(HColumnDescriptor.setBlockSize())，默认值是64KB，大号的Block有利于顺序Scan，小号Block利于随机查询，因而需要权衡。Meta块是可选的，FileInfo是固定长度的块，它纪录了文件的一些Meta信息，例如：AVG_KEY_LEN, AVG_VALUE_LEN, LAST_KEY, COMPARATOR, MAX_SEQ_ID_KEY等。Data Index和Meta Index纪录了每个Data块和Meta块的其实点、未压缩时大小、Key(起始RowKey？)等。Trailer纪录了FileInfo、Data Index、Meta Index块的起始位置，Data Index和Meta Index索引的数量等。其中FileInfo和Trailer是固定长度的。<br>HFile里面的每个KeyValue对就是一个简单的byte数组。但是这个byte数组里面包含了很多项，并且有固定的结构。我们来看看里面的具体结构：<br><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-ab916c90abbc18bd.png" alt="img"><br>上图可知，开始是两个固定长度的数值，分别表示key的长度和alue的长度。紧接着是Key,开始是固定长度的数值，表示RowKey的长度，紧接着是RowKey，然后是固定长度的数值，表示Family的长度，然后是Family,接着是Qualifier，然后是两个固定长度的数值，表示Time Stamp和Key Type(Put/Delete)。Value部分没有那么复杂的结构，就是纯粹的二进制数据。</p>
</li>
<li><p>HLog<br>HLog(WAL log)：WAL意为write ahead log，用来做灾难恢复使用，HLog记录数据的所有变更，一旦region server 宕机，就可以从log中进行恢复。<br>HLog文件就是一个普通的Hadoop Sequence File， Sequence File的value是key时HLogKey对象，其中记录了写入数据的归属信息，除了table和region名字外，还同时包括sequence number和timestamp，timestamp是写入时间，sequence number的起始值为0，或者是最近一次存入文件系统中的sequence number。 Sequence File的value是HBase的KeyValue对象，即对应HFile中的KeyValue。<br><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-24ffadaa0c5afc54.jpg" alt="img"><br>上图中是HLog文件的结构，其实HLog文件就是一个普通的Hadoop Sequence File，Sequence File的Key是HLogKey对象，HLogKey中记录了写入数据的归属信息，除了table和Region名字外，同时还包括sequence number和timestamp,timestamp是”写入时间”，sequence number 的起始值为0，或者是最近一次存入文件系统中的sequence number。<br>HLog Sequence File 的Value是HBase的KeyValue对象昂，即对应HFile中的KeyValue。</p>
</li>
</ul>
<h2 id="HRegion定位"><a href="#HRegion定位" class="headerlink" title="HRegion定位"></a>HRegion定位</h2><p><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-ad4aa2158f4c7b00.jpg" alt="img"></p>
<p>通过zk里的文件/hbase/rs得到-ROOT-表的位置。-ROOT-表只有一个region。<br>通过-ROOT-表查找.META.表的第一个表中相应的region的位置。其实-ROOT-表是.META.表的第一个region；.META.表中的每一个region 在-ROOT-表中都是一行记录。<br>通过.META.表找到所要的用户表region的位置。用户表中的每个region在.META.表中都是一行记录。</p>
<p>-ROOT-表永远不会被分隔为多个region，保证了最多需要三次跳转，就能定位到任意的region。client会将查询的位置信息保存缓存起来，缓存不会主动失效，因此如果client上的缓存全部失效，则需要进行6次网络来回，才能定位到正确的region，其中三次用来发现缓存失效，另外三次用来获取位置信息。</p>
<p>从0.96版本以后，三层架构被改为二层架构，-ROOT-表被去掉了，同时zk中的/hbase/root-region-server也被去掉了。直接把.META.表所在的RegionServer信息存储到了zk中的/hbase/meta-region-server去了。再后来引入了namespace，.META.表这样别扭的名字被修改成了hbase:meta。<br><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/20180628161225487.png" alt="img"></p>
<p>二层架构的定位步骤如下：</p>
<ol>
<li>用户通过查找zk（zookeeper）的/hbase/meta-region-server节点查询哪台RegionServer上有hbase:meta表。</li>
<li>客户端连接含有hbase:meta表的RegionServer。Hbase:meta表存储了所有Region的行健范围信息，通过这个表就可以查询出你要存取的rowkey属于哪个Region的范围里面，以及这个Region又是属于哪个RegionServer。</li>
<li>获取这些信息后，客户端就可以直连其中一台拥有你要存取的rowkey的RegionServer，并直接对其操作。</li>
<li>客户端会把meta信息缓存起来，下次操作就不需要进行以上加载HBase:meta的步骤了。</li>
</ol>
<h1 id="HBase工作流程"><a href="#HBase工作流程" class="headerlink" title="HBase工作流程"></a>HBase工作流程</h1><p><img src="/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/HBase%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/6542029-a57ca2352273bbf8.png" alt="img"></p>
<ul>
<li><p>Client<br>首先当一个请求产生时，HBase Client使用RPC(远程过程调用)机制与HMaster和HRegionServer进行通信，对于管理类操作，Client与HMaster进行RPC;对于数据读写操作，Client与HRegionServer进行RPC。</p>
</li>
<li><p>Zookeeper<br>HBase Client使用RPC(远程过程调用)机制与HMaster和HRegionServer进行通信，但如何寻址呢？由于Zookeeper中存储了-ROOT-表的地址和HMaster的地址，所以需要先到Zookeeper上进行寻址。<br>HRegionServer也会把自己以Ephemeral方式注册到Zookeeper中，使HMaster可以随时感知到各个HRegionServer的健康状态。此外，Zookeeper也避免了HMaster的单点故障。</p>
</li>
<li><p>HMaster<br>当用户需要进行Table和Region的管理工作时，就需要和HMaster进行通信。HBase中可以启动多个HMaster,通过Zookeeper的Master Eletion机制保证总有一个Master运行。<br>管理用户对Table的增删改查操作<br>管理HRegionServer的负载均衡，调整Region的分布<br>在Region Split后，负责新Region的分配<br>在HRegionServer停机后，负责失效HRegionServer上的Regions迁移</p>
</li>
<li><p>HRegionServer<br>当用户需要对数据进行读写操作时，需要访问HRegionServer。HRegionServer存取一个子表时，会创建一个HRegion对象，然后对表的每个列族创建一个Store实例，每个Store都会有一个 MemStore和0个或多个StoreFile与之对应，每个StoreFile都会对应一个HFile， HFile就是实际的存储文件。因此，一个HRegion有多少个列族就有多少个Store。 一个HRegionServer会有多个HRegion和一个HLog。</p>
</li>
<li><p>注意：HStore存储由两部分组成：MemStore和StoreFiles。 MemStore是Sorted Memory Buffer,用户写入数据首先会放在MemStore,当MemStore满了以后会Flush成一个 StoreFile（实际存储在HDHS上的是HFile），当StoreFile文件数量增长到一定阀值，就会触发Compact合并操作，并将多个StoreFile合并成一个StoreFile，合并过程中会进行版本合并和数据删除，因此可以看出HBase其实只有增加数据，所有的更新和删除操作都是在后续的compact过程中进行的，这使得用户的 读写操作*只要进入内存中就可以立即返回，保证了HBase I/O的高性能。</p>
</li>
</ul>
<h1 id="HBase的高可用"><a href="#HBase的高可用" class="headerlink" title="HBase的高可用"></a>HBase的高可用</h1><ul>
<li>HDFS机架识别策略：当数据文件损坏时，会找相同机架上备份的数据文件，如果相同机架上的数据文件也损坏会找不同机架备份数据文件。</li>
<li>HBase的Region快速恢复：当regionserver损坏时，master会对该regionserver上的region进行重新分配，迁移到其他可用的regionserver上并恢复region。</li>
<li>Master节点的HA机制：Master为一主多备。当Master主节点宕机后，剩下的备节点通过选举，产生主节点。</li>
</ul>
</div><div class="tags"><a href="/tags/hadoop%E4%BD%93%E7%B3%BB/">hadoop体系</a></div><div class="post-nav"><a class="pre" href="/2019/08/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hbase/region%E4%BB%8B%E7%BB%8D/">2. region介绍</a><a class="next" href="/2019/07/24/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%E4%BD%93%E7%B3%BB/hive/hive%20MR%E9%85%8D%E7%BD%AE/">hive MR配置</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://cunmin1718.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Beat/">Beat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES/">ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Elasticsearch/">Elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kibana/">Kibana</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Logstash/">Logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nexus/">Nexus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ansible/">ansible</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/drill/">drill</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ganglia/">ganglia</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gitLab/">gitLab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/greenplum/">greenplum</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/greenplum/PostgreSQL/">PostgreSQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/impala/">impala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/oracle/">oracle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/seaweed/">seaweed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/">数据仓库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/" style="font-size: 15px;">数据仓库</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">容器</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" style="font-size: 15px;">项目开发</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 15px;">运维</a> <a href="/tags/ELK/" style="font-size: 15px;">ELK</a> <a href="/tags/hadoop%E4%BD%93%E7%B3%BB/" style="font-size: 15px;">hadoop体系</a> <a href="/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/" style="font-size: 15px;">文件存储</a> <a href="/tags/%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E/" style="font-size: 15px;">分析引擎</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/tags/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7/" style="font-size: 15px;">运维监控</a> <a href="/tags/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/" style="font-size: 15px;">日志收集</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/ELK/Logstash/pipeline%E9%85%8D%E7%BD%AE/">pipeline配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/ELK/Logstash/Logstash%E4%BB%8B%E7%BB%8D/">Logstash介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/ELK/FileBeat6.4%E5%AE%89%E8%A3%85/">FileBeat6.4 安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/ELK/Logstash/logstash7.4%20%E9%85%8D%E7%BD%AE/">Logstash7.4 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/ELK/Kibana/Kibana7.4%E5%AE%89%E8%A3%85/">Kibana7.4安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/ELK/ElasticSearch/ES%207.4%E5%AE%89%E8%A3%85/">ES 7.4安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/02/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/Maven/15.%20%E6%8F%92%E4%BB%B6maven-enforcer-plugin/">插件maven-enforcer-plugin</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/02/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/Maven/14.%20%E6%8F%92%E4%BB%B6build-helper-maven-plugin/">插件build-helper-maven-plugin</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/02/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/Inmon%20%20VS%20Kimball/">3. Bill Inmon  VS. Ralph Kimball</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95/">2. 数据仓库建设中的数据建模方法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">记忆不靠谱.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>